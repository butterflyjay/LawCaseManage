"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileWatcher = exports.EWatcherType = void 0;
const application_1 = require("./application");
const staticresource_1 = require("../web/staticresource");
const webcache_1 = require("../web/webcache");
const util_1 = require("./util");
const instancefactory_1 = require("../main/instancefactory");
const webconfig_1 = require("../web/webconfig");
/**
 * 文件监听类型
 * @since 0.4.4
 */
var EWatcherType;
(function (EWatcherType) {
    EWatcherType[EWatcherType["STATIC"] = 1] = "STATIC";
    EWatcherType[EWatcherType["DYNAMIC"] = 2] = "DYNAMIC"; //动态资源，主要为模块
})(EWatcherType = exports.EWatcherType || (exports.EWatcherType = {}));
/**
 * file watch 类
 * 用于监听 静态文件或instance(动态)文件的改变
 * 静态文件改变后会更新web cache
 * instance文件改变后，更新实例工厂，仅对“注解类”实例有效
 * @since 0.4.4
 */
class FileWatcher {
    /**
     * 添加监听目录
     * @param path      目录路径
     * @param type      类型
     */
    static addDir(path, type) {
        //不重复监听
        if (this.directoryMap.has(path)) {
            return;
        }
        this.directoryMap.set(path, type);
        switch (type) {
            case EWatcherType.STATIC:
                this.watchStatic(path);
                break;
            case EWatcherType.DYNAMIC:
                this.watchDynamic(path);
                break;
        }
    }
    /**
     * 删除监听目录
     * @param path      目录路径
     */
    static removeDir(path) {
        this.directoryMap.delete(path);
        application_1.App.fs.unwatchFile(path);
    }
    /**
     * 监听静态资源目录
     * @param path  目录路径
     */
    static async watchStatic(path) {
        //针对使用server cache的配置有效
        if (!webconfig_1.WebConfig.useServerCache) {
            return;
        }
        //支持recursive
        if (process.platform === 'darwin' || process.platform === 'win32') {
            application_1.App.fs.watch(path, { recursive: true }, async (eventType, fileName) => {
                //文件不存在或监听类型为rename，则返回
                if (!fileName || eventType === 'rename') {
                    return;
                }
                let path1 = application_1.App.path.resolve(path, fileName);
                await this.handleStaticRes(path1);
            });
        }
        else {
            application_1.App.fs.watch(path, async (eventType, fileName) => {
                //文件不存在或监听类型为rename，则返回
                if (!fileName || eventType === 'rename') {
                    return;
                }
                let path1 = application_1.App.path.resolve(path, fileName);
                await this.handleStaticRes(path1);
            });
            const dir = application_1.App.fs.readdirSync(path, { withFileTypes: true });
            for (let dirent of dir) {
                if (!dirent.isDirectory()) {
                    continue;
                }
                //处理子目录
                this.addDir(application_1.App.path.resolve(path, dirent.name), EWatcherType.STATIC);
            }
        }
    }
    /**
     * 监听动态资源目录
     * @param path  路径
     */
    static watchDynamic(path) {
        application_1.App.fs.watch(path, async (eventType, fileName) => {
            //文件不存在或不为js文件则返回
            if (!fileName || !fileName.endsWith('.js')) {
                return;
            }
            let path1 = application_1.App.path.resolve(path, fileName);
            //删除require 缓存
            delete require.cache[path1];
            //文件不存在，则不需要加载
            if (!application_1.App.fs.existsSync(path1)) {
                return;
            }
            let r = require(path1);
            let cls;
            //不同生成方法，r对象不同
            //非class，需要取出class
            if (!r.prototype) {
                let props = Object.getOwnPropertyNames(r);
                for (let p of props) {
                    //类
                    if (typeof r[p] === 'function' && r[p].prototype) {
                        cls = r[p];
                        break;
                    }
                }
            }
            else {
                cls = r;
            }
            if (cls) {
                //更新该类注入
                setImmediate(() => {
                    instancefactory_1.InstanceFactory.updInject(cls);
                });
            }
        });
    }
    /**
     * 处理单个静态目录
     * @param path  监听目录
     */
    static async handleStaticRes(path) {
        let url = util_1.Util.getRelPath(path);
        let obj = await webcache_1.WebCache.getCacheData(url);
        //如果webcache缓存该文件，则需要加入缓存
        if (obj && (obj.data || obj.zipData)) {
            let zip = obj.zipData ? true : false;
            let data = await staticresource_1.StaticResource.readFile(path, zip);
            webcache_1.WebCache.add(url, data);
        }
    }
}
exports.FileWatcher = FileWatcher;
/**
 * 监听目录map，键为路径，值为类型，类型包括static(静态)和dynamic(动态)
 */
FileWatcher.directoryMap = new Map();
//# sourceMappingURL=filewatcher.js.map