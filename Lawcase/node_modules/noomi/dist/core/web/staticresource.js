"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticResource = void 0;
const webcache_1 = require("./webcache");
const webconfig_1 = require("./webconfig");
const util_1 = require("../tools/util");
const application_1 = require("../tools/application");
const filewatcher_1 = require("../tools/filewatcher");
/**
 * 静态资源加载器
 */
class StaticResource {
    /**
     * 加载静态资源
     * @param request   request
     * @param response  response
     * @param path      文件路径
     * @param zip       是否压缩
     * @returns         http code 或 缓存数据
     */
    static async load(request, response, path, zip) {
        //检测路径是否在static map中
        let finded = false;
        for (let p of this.staticMap) {
            if (p[1].test(path)) {
                finded = true;
                break;
            }
        }
        if (!finded) {
            return 404;
        }
        //文件路径
        let filePath = util_1.Util.getAbsPath([path]);
        //缓存数据对象
        let cacheData;
        //状态码
        if (webconfig_1.WebConfig.useServerCache) { //从缓存取，如果用浏览器缓存数据，则返回0，不再操作
            let ro = await webcache_1.WebCache.load(request, response, path);
            if (ro !== undefined && typeof ro === 'object') {
                cacheData = ro;
            }
        }
        //不存在缓存数据，或者请求为gzip但不存在zipData，需要读取文件
        if (cacheData === undefined || (zip && !cacheData['zipData'])) {
            if (!application_1.App.fs.existsSync(filePath) || !application_1.App.fs.statSync(filePath).isFile()) {
                return 404;
            }
            else {
                cacheData = await this.readFile(filePath, zip);
                if (webconfig_1.WebConfig.useServerCache) {
                    await webcache_1.WebCache.add(path, cacheData);
                }
            }
        }
        return cacheData;
    }
    /**
     * 添加静态路径
     * @param paths   待添加的目录或目录数组
     */
    static addPath(paths) {
        if (!Array.isArray(paths)) {
            if (typeof paths === 'string') {
                if (application_1.App.fs.existsSync(util_1.Util.getAbsPath([paths]))) {
                    this.staticMap.set(paths, util_1.Util.toReg(paths, 1));
                    //添加 file watcher
                    if (application_1.App.openWatcher) {
                        filewatcher_1.FileWatcher.addDir(util_1.Util.getAbsPath([paths]), filewatcher_1.EWatcherType.STATIC);
                    }
                }
            }
        }
        else {
            paths.forEach(item => {
                if (typeof item === 'string') {
                    this.addPath(item);
                }
            });
        }
    }
    /**
     * 读文件
     * @param path      绝对路径
     * @param zip       压缩方法
     * @returns         cache数据对象
     */
    static async readFile(path, zip) {
        const fs = application_1.App.fs;
        //未压缩数据buffer
        let srcBuf;
        //压缩数据buffer
        let zipBuf;
        const stream = application_1.App.stream;
        const zlib = application_1.App.zlib;
        const util = application_1.App.util;
        const pipeline = util.promisify(stream.pipeline);
        //mime 类型
        let mimeType = application_1.App.mime.getType(path);
        //源文件流
        let srcStream;
        //zip文件流
        let zipStream;
        let srcBufs = [];
        let zipBufs = [];
        let tmpFn;
        //创建输入流
        srcStream = fs.createReadStream(path);
        //从源输入流读数据
        srcBuf = await new Promise((res, rej) => {
            srcStream.on('data', (buf) => {
                srcBufs.push(buf);
            });
            srcStream.on('end', () => {
                res(Buffer.concat(srcBufs));
            });
        });
        //不缓存数据标志
        let saveData = this.checkNeedZip(mimeType);
        if (zip && saveData) {
            //生成临时文件
            tmpFn = application_1.App.path.resolve(application_1.App.path.dirname(path), application_1.App.uuid.v1());
            //zip对象
            let zipTool;
            //根据不同类型压缩
            if (zip) {
                zipTool = zlib.createGzip();
            }
            //创建压缩管道
            await pipeline(fs.createReadStream(path), zipTool, application_1.App.fs.createWriteStream(tmpFn));
            //创建压缩输入流
            zipStream = fs.createReadStream(tmpFn);
            //从zip输入流读数据
            zipBuf = await new Promise((res, rej) => {
                zipStream.on('data', (buf) => {
                    zipBufs.push(buf);
                });
                zipStream.on('end', () => {
                    res(Buffer.concat(zipBufs));
                    //删除临时压缩文件
                    fs.unlink(tmpFn, (err) => {
                        if (err) {
                            console.log(err);
                        }
                    });
                });
            });
        }
        //文件信息
        let stat = fs.statSync(path);
        //最后修改 
        let lastModified = stat.mtime.toUTCString();
        //计算hash
        const hash = application_1.App.crypto.createHash('md5');
        hash.update(srcBuf, 'utf8');
        let etag = hash.digest('hex');
        //数据大小
        let dataSize = stat.size;
        //数据
        let data;
        //压缩大小
        let zipSize;
        //压缩数据
        let zipData;
        if (saveData) {
            data = srcBuf.toString('binary');
            if (zipBuf) {
                zipSize = zipBuf.length;
                zipData = zipBuf.toString('binary');
            }
        }
        return {
            etag: etag,
            lastModified: lastModified,
            mimeType: mimeType,
            dataSize: dataSize,
            zipSize: zipSize,
            data: data,
            zipData: zipData
        };
    }
    /**
     * 检查mime类型文件是否需要压缩
     * @param mimeType
     */
    static checkNeedZip(mimeType) {
        if (!mimeType) {
            return false;
        }
        //判断是否为可压缩类型
        for (let reg of this.zipTypes) {
            if (reg.exec(mimeType) !== null) {
                return true;
            }
        }
        return false;
    }
}
exports.StaticResource = StaticResource;
/**
 * 静态资源map，用于管理可访问静态资源路径，目录可以带通配符‘*’
 */
StaticResource.staticMap = new Map();
/**
 * 可压缩类型，也是缓存类型
 */
StaticResource.zipTypes = [
    /^text\/\S+$/,
    /^application\/\S*script$/,
    /^application\/json$/
];
//# sourceMappingURL=staticresource.js.map